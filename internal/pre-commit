#!/bin/bash
# Executed in root directory of tree; simply executed upon commit so the 
# state of the tree is as-is.
set -o nounset
set -o errexit
set -f # No pathname expansion

#------------------------------------------------------------
# Checkout commit to staging area 

repo_root=$(git rev-parse --show-toplevel)
old_version=$(mktemp -d -t gpk)
new_version=$(mktemp -d -t gpk)
one_log=$(mktemp -t gpk)
exit_script=$(mktemp -t gpk)
function cleanup {
    rm -rf "$new_version"
    rm -rf "$old_version"
    rm $one_log
    rm $exit_script
}
trap cleanup EXIT

# FIXME: Make this more efficient by using a persistent clone or something?
git clone --quiet --local --shared "$repo_root" "$old_version"

mkdir -p "$new_version"
git checkout-index --prefix="$new_version"/ -af

# Load helpers from latest version
source "$new_version"/gpk/internal/helpers.sh

echo true > "$exit_script"
chmod +x "$exit_script"

red="$(tput setaf 1)"
yellow="$(tput setaf 3)"
normal="$(tput sgr0)"

#------------------------------------------------------------
# Iterate over changed files
# For efficiency's sake, we're only going to check changed files.

#------------------------------------------------------------
# Read list of changed files and go

# This spawns a subshell because of the pipe, so we can't use
# variables to communicate upwards.
(git diff -z --cached --name-only --diff-filter=ACMR) | while IFS= read -r -d '' file; do
    apply_precommits "$file"
done

if ! "$exit_script"; then
    echo "[${yellow}gpk${normal}] One or more pre-commit checks failed. Please fix them and commit again." >&2
fi

"$exit_script"
